一.简单工厂模式
simplefactory
example2:简单工厂模式示例
	Factory:简单工厂
	Api:工厂要创建的对象接口
	ImplA,ImplB:具体对象
	简单工厂类中 提供方法,用于创建具体的不同对象

二.外观模式
facade

三.适配器模式
adapter

四.单例模式

五.工厂方法模式
factory method
example2:工厂方法模式 示例 
example3:工厂方法模式 应用
	ExportOperate:工厂方法类,提供抽象
example5:一个工厂方法类中Creator,可以包含多个创建不同对象的工厂方法.但是这些工厂方法通常只在当前类中使用,最终不会暴露给客户端

六.抽象工厂模式
abstract factory
提供一个创建 一系列相关或相互依赖对象的接口,而无需指定它们具体的类.
解决的具体问题:1.只知道创建的一系列对象的接口,而不知具体实现(cpu和mainBoard)
          2.这一系列对象是相关或相互依赖的(cpu和mainBoard的针脚应相同)
          即 既要创建接口的对象,还要约束它们之间的关系.

抽象工厂定义了一系列相关的产品,用于创建一系列相关的产品.

与 简单工厂 或 工厂方法 模式的区别
这两者 只关心创建单个产品类型的对象,如创建CPU的工厂方法只关心如何创建cpu对象.创建主板的工厂方法,只关心如何创建主板对象.
而抽象工厂模式,要创建一系列类型的对象(cpu和主板),最终组成所需的对象(电脑).

抽象工厂接口中定义的工厂方法,延迟到了具体的工厂实现类中实现.

example1:使用 简单工厂 模式 实现 电脑组装
example2:抽象工厂模式的 示例实现

example3:抽象工厂模式 实现电脑组装匹配的主板和cpu P136

example4:以上的抽象工厂模式 有一个小问题,即若想在抽象工厂接口中添加一种新的产品类型,则需要更改所有实现该接口的实现类(都需要添加该方法)
                           可拓展的抽象工厂的实现  
          
example5:支持xml和database等多种数据源的dao 抽象工厂 实现

七.生成器模式
builder
将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示.
生成器 分离了 构建算法 和 具体的构造实现
example2:生成器模式的标准实现

example3:生成器模式重写 使用xml和text不同方式导出data中的data头部,data主体,data尾部.















