一.创建型模式
用于类的实例化.是对象创建方法.在适当情况下以适当形式创建对象
0.简单工厂模式Simple Factory

1.工厂方法模式Factory Method(返回一个产品多个子类中的一个)factorymethod
定义一个用于创建对象的接口,让子类决定实例化哪个类,Factory Method使得一个类的实例化延迟到其子类中
本质:延迟到子类来选择实现
使用工厂类实例化不同对象
使用场景
(1)当需要创建一个类,且在编程时不能确定具体类型,需要运行时确定
(2)当一个类希望由其子类来指定所创建对象的具体类型时
(3)想要定位被创建类,并获取相关信息时

模式区别:简单工厂模式 和 工厂方法模式 研磨p121
相同点:本质 都是 选择实现
不同点:简单工厂:直接在工厂类中"选择实现"
              工厂方法:将"选择实现"延迟到子类中
工厂方法模式可以退化成"简单工厂模式"

2.抽象工厂模式Abstract Factory
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
本质:选择 产品簇的实现
即 既要创建不同接口的对象,还要约束它们之间的关系.
(即多个抽象产品类相互关联.每个抽象工厂类生产这些产品(将这些产品进行组合))
抽象工厂比工厂方法模式的 抽象层次更高.即抽象工厂返回的是一组类的工厂.
(即抽象工厂返回的是工厂,而工厂再返回多个子类中的一个)

工厂方法模式 和 抽象工厂模式 区别
工厂方法模式			抽象工厂模式			
一个抽象产品类			多个抽象产品类
它可派生多个具体产品类	每个抽象产品类可派生出多个具体产品类
一个抽象工厂类			一个抽象工厂类
可派生多个具体工厂类		可以派生出多个具体工厂类

3.生成器模式(建造模式)Builder
将复杂对象的构建过程和它的表示方式相分离,则在相同的构建过程中能创建出不同的表示方式
StringBuffer和StringBuilder为生成器模式

4.单例模式Singleton
四种实现方式
(1)饿汉式:提前初始化实例.线程安全,因为虚拟机保证类只被装载一次,装载类时不会产生并发问题
(2)懒汉式:延迟初始化实例,加锁 并 双重判断
(3)静态内部类实现
(4)枚举类实现:枚举实现最安全

私有化构造方法仍可以通过反射暴力访问,将构造器设置成第二次调用时直接抛异常

5.原型模式Prototype
系统开销(时间和存储空间).
原型即克隆.复制对象.克隆出的对象副本被初始化为调用克隆方法时原始对象的当前状态.即对象的克隆避免了创建新对象.
克隆涉及	浅层复制	和	深层复制

浅层复制:当原始对象变化时,新对象也随之改变.即浅层复制只是对原有对象的一个引用
深层复制:当原始对象变化时,新对象不受影响,即原始对象所包含的所有参数,新对象都建立了拷贝

浅拷贝中:
当复制基本数据类型对象时,每个对象均有一份
当复制引用类型变量时,保存的是引用

Java内置克隆方法,实现Cloneable接口,调用Object类中的clone()方法完成对象的克隆.
clone()方法会占用java堆中的一块内存
内存的大小与原始对象的大小相同.它会对原始对象的所有字段执行按位复制,复制到克隆对象的相应字段中.即浅层复制

Cloneable接口:不包含方法.它决定了Object中受保护的clone方法实现的行为:若一个类实现了Cloneable,
Object的clone方法就会返回该对象逐域拷贝,否则就会抛出CloneNotSupportedException异常


二.结构型模式
描述将 对象 和 类 组合在一起以便组成更复杂的结构,共7种
对象结构型模式:对象之间相互关联组织
类结构型模式:实现基于继承的代码抽象

6.适配器模式Adapter
为一个已有的类提供一个新的接口,并在客户端请求不同接口时实现类的重用
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	若有一段代码写的很烂但是又不得不调用,可以编写适配器包装该代码.再调用用自定义的接口即可.
	
	思路:定义一个类来实现新接口,该类内部持有原有对象,转调旧接口中的功能.
	
7.桥接模式Bridge
允许我们将类与其接口相互解耦,允许类及其接口随着时间相互独立变化,增加类重用的次数,提高后序可扩展性,
也允许运行时对接口的不同实现方式动态切换,使代码更灵活.
将抽象部分与它的实现部分分离,使它们都可以独立地变化。

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。
它通过提供抽象化(遥控器RemoteControl)和实现化(TV)之间的桥接结构，来实现二者的解耦。
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

8.组合模式Composite
为客户端处理各种复杂和灵活的树状结构.这些结构可以由各种不同类型的容器和叶子结点组成.其深度或组合形式能够
在运行时调整或确定
将对象组合成树形结构以表示"部分-整体"的层次结构。"Composite使得用户对单个对象和组合对象的使用具有一致性。"
算数表达式就是一种组合模式
操作系统中的文件系统

9.装饰模式Decorator
允许我们通过附加新的功能或修改现有功能,在运行时动态的修改对象
 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
IO API 

10.门面模式(外观模式)Facade
注重解耦,强调代码抽象,提供简单接口并隐藏其后的复杂性
运行我们为客户端创建一个统一的接口以访问不同子系统的不同接口,从而简化客户端
为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。
它隐藏了系统内部的复杂结构(隐藏大厦里复杂的结果)并为客户端提供一个简单的接口(只展示大厦的外观),以便客户端对系统进行访问
JDBC接口	使用java.sql.Connection接口,但不关心其具体实现方法.实现只需要由系统提供的底层驱动来完成
汽车转动钥匙--完成所有点火等内部操作

11.代理模式Proxy
为其他对象提供一种代理以控制这个对象的访问.该模式的目的是一个对象不适合或不能直接引用另一个对象,简化客户端并实现
对象访问,同时避免任何副作用
分类:
对象行为型模式:使用对象组合而非继承,描述一组对象如何合作执行部分任务,
定义:为其他对象 提供一种代理 以 控制 对这个对象的访问
本质:控制对象访问

12.享元模式Flyweight
减少用于创建和操作大量相似的细碎对象所花费的成本.
用于需要创建大量类似性质的对象.大量的对象会消耗高内存,享元模式给出了一个解决方案,即通过共享对象来减少内存负载
具体实现:根据对象属性将对象分成两种类型:内蕴状态   和	外蕴状态
复用相同对象来减少对象创建的数量.
客户端调用类时会在运行时创建大量对象,该模式会重新设计类以优化内存开销

三.行为型模式
关注对象间相互通信(交互)的设计模式.对象间既能保证交换数据,同时仍能保持松耦合

13.责任链模式COR
发送端发送一个请求到一个对象链中,链中的对象自行处理请求.
若链中的对象决定不响应请求,它会将请求转发给链中的下一个对象.直到有一个对象处理该事件,一旦事件被处理则请求传递过程终止
目的:对请求的发送者和接受者之间解耦
Servlet过滤器Filter
Java异常处理机制:catch列表从上到下扫描,若第一个异常对象可以处理异常则完成任务,否则责任转移到下一行

14.命令模式Command
发送者(调用操作的对象)与接收者(接收请求并执行特定操作)之间完全解耦.
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化

15.解释器模式Interpreter
解析特定语法的设计模式.对于特定的某种语言,解释器模式能够定义针对其语法表示形式的解释器.并实现对该语言语句的翻译和解释.


16.迭代器模式Iterator
不考虑数据存储方式而直接对各种类型的数据进行迭代.
thinkingInJava:page226:迭代器是一个对象,它的工作是遍历并选择序列中的对象.而客户端不必知道或关系该序列底层的结构.
此外,迭代器通常被称为 轻量级对象,创建它的代价小.因此,经常可以见到对迭代器有些奇怪的限制.
Java的Iterator只能单向移动

17.中介者模式Mediator
关于数据交互的设计模式.核心是中介者对象.
负责协调一系列对象(同事类)间一系列不同的数据请求
定义:用一个中介对象 来 封装 一系列的对象交互.中介者使得各对象不需要显式的相互引用.从而使其耦合松散,而且可以独立的改变它们之间的交互.

18.备忘录模式Memento
使对象回复到其以前状态的能力(通过回滚撤销)
保存一个对象的某个状态，以便在适当的时候恢复对象
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。
两个对象:
发起者:具有内部状态的某个对象
管理者:对发起者执行一些操作,并实现撤销更改

19.观察者模式Observer
被观察者 维护了 观察者对象的集合.当被观察者对象编号时,它会通知观察者
被观察者对象锁维护的观察者集合中能够添加或删除观察者
推送
被观察者的状态变化能够传递给观察者
提供商 听众
定义:定义对象间的一种 一对多的依赖关系.当一个对象的状态发送改变时,所有依赖于它的对象都得到通知并被自动更新.
本质:触发联动

定义了一个对象(主题)与多个依赖者之间的一对多的依赖，这样一来，当这个对象改变时，它的所有的依赖者都会收到通知并自动更新。
服务号中维护了所有向它订阅消息的使用者，当服务号有新消息时，通知所有的使用者。整个架构是一种松耦合，主题的实现不依赖与使用者，
当增加新的使用者时，主题的代码不需要改变；使用者如何处理得到的数据与主题无关；

20.状态模式State
根据状态变化来改变对象的行为.P133
允许对象根据内部状态(内容类)实现不同的行为.
内容类可有大量内部状态,每当对内容类调用request方法时,消息就会被委托给状态类进行处理
媒体播放器的控制面板:当播放音乐时,播放按钮可以暂停和重新启动音乐...
类的行为是基于它的状态改变的
对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

21.策略模式Strategy
1.策略模式thinkingInJava P175
interfaces/classprocessor/Apply.java
(1)
创建一个能够根据 所传递 的  参数对象的不同 而 具有不同行为 的方法.
这类方法 包含 所要 执行的算法中 固定不变的部分,而"策略"包含变化的部分.
策略就是传递进去的参数对象,包含要执行的代码.

用于需要使用不同算法来处理不同的数据(对象)时.P136
即策略模式定义了一系列算法,并可以替换使用.
一种可在运行时选择算法的设计模式
可使算法独立于调用算法的客户端
去机场的交通方式,旅客可选择自驾,出租车等,可互相替换.旅客可根据需要选择策略
多种排序算法,但使用时只能使用一个
一个类的行为或其算法可以在运行时更改
行为 与 对象 分离

定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。
定义了算法族(各个接口,不同的行为)，分别封装起来，让它们之间可相互替换(在客户基类里作为属性替换)，
此模式让算法的变化独立于使用算法的客户(Role)。

22.模板方法模式TemplateMethod
类行为模式.会定义算法的各个执行步骤.
算法的一个或多个步骤可由子类通过重写来实现,同时保证算法的完整性并能够实现多种不同的功能
模板方法会由一个抽象类实现.该类中有一个方法用来定义算法的各个步骤,这些步骤的具体实现会放到子类中.
房屋建筑商会使用该模板方法来建筑一座新大楼

23.访问者模式Visitor
简化对象相关的操作的分组.这些操作由访问者来执行,而不是放在被访问的类中
我们使用了一个访问者类，它改变了元素类的执行算法。
通过这种方式，元素的执行算法可以随着访问者改变而改变。

24.空对象模式(Null Object Pattern)
一个空对象取代 NULL 对象实例的检查。

25.
z07listener
监听器























































